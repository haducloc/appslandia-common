// The MIT License (MIT)
// Copyright Â© 2015 Loc Ha

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

package com.appslandia.common.jdbc;

import java.io.OutputStream;
import java.io.Writer;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import javax.sql.DataSource;

import com.appslandia.common.base.DangerTaskConfirm;
import com.appslandia.common.threading.ThreadLocalStorage;
import com.appslandia.common.utils.Arguments;
import com.appslandia.common.utils.ObjectUtils;
import com.appslandia.common.utils.STR;

/**
 *
 * @author Loc Ha
 *
 */
public class ConnectionImpl implements Connection {

  protected final Connection conn;
  protected final String dataSourceId;

  protected ConnectionImpl outer;

  public ConnectionImpl(DataSource dataSource) throws java.sql.SQLException {
    this(dataSource, null);
  }

  public ConnectionImpl(DataSource dataSource, String dataSourceId) throws java.sql.SQLException {
    var outer = CONNECTION_HOLDER.get();
    if (outer != null) {
      this.outer = outer;
    }

    this.conn = dataSource.getConnection();
    this.dataSourceId = dataSourceId;

    CONNECTION_HOLDER.set(this);
  }

  public ConnectionImpl(DataSourceWrapper dataSource) throws java.sql.SQLException {
    this(dataSource, dataSource.getName());
  }

  // PrepareStatement utilities

  public PreparedStatementImpl prepareStatement(SqlQuery pQuery) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(pQuery.getTranslatedQuery()), pQuery, getDbDialect());
  }

  public PreparedStatementImpl prepareStatement(SqlQuery pQuery, boolean autoGeneratedKeys)
      throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(pQuery.getTranslatedQuery(),
        autoGeneratedKeys ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS), pQuery, getDbDialect());
  }

  public PreparedStatementImpl prepareStatement(SqlQuery pQuery, int[] columnIndexes) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(pQuery.getTranslatedQuery(), columnIndexes), pQuery,
        getDbDialect());
  }

  public PreparedStatementImpl prepareStatement(SqlQuery pQuery, String[] columnNames) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(pQuery.getTranslatedQuery(), columnNames), pQuery,
        getDbDialect());
  }

  public PreparedStatementImpl prepareStatement(SqlQuery pQuery, int resultSetType, int resultSetConcurrency)
      throws java.sql.SQLException {
    return new PreparedStatementImpl(
        this.conn.prepareStatement(pQuery.getTranslatedQuery(), resultSetType, resultSetConcurrency), pQuery,
        getDbDialect());
  }

  public PreparedStatementImpl prepareStatement(SqlQuery pQuery, int resultSetType, int resultSetConcurrency,
      int resultSetHoldability) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(pQuery.getTranslatedQuery(), resultSetType,
        resultSetConcurrency, resultSetHoldability), pQuery, getDbDialect());
  }

  // Update Utilities

  public void dropTables(DangerTaskConfirm taskConfirm, String... tableNames) throws java.sql.SQLException {
    Arguments.isTrue(taskConfirm == DangerTaskConfirm.DANGER_TASK_CONFIRMED);

    for (String tableName : tableNames) {
      executeUpdate(STR.fmt("DROP TABLE IF EXISTS {}", this.getDbDialect().quoteIdentifier(tableName)));
    }
  }

  public void backupTables(String... tableNames) throws java.sql.SQLException {
    for (String tableName : tableNames) {
      backupTable(tableName, null);
    }
  }

  public int backupTable(String originalTable, String backupTable) throws java.sql.SQLException {
    if (backupTable == null) {
      backupTable = originalTable + "_BAK";
    }
    var dbDialect = this.getDbDialect();
    if (dbDialect.getType() == DbType.MSSQL) {

      return executeUpdate(STR.fmt("SELECT * INTO {} FROM {}", dbDialect.quoteIdentifier(backupTable),
          dbDialect.quoteIdentifier(originalTable)));
    }
    return executeUpdate(STR.fmt("CREATE TABLE {} AS SELECT * FROM {}", dbDialect.quoteIdentifier(backupTable),
        dbDialect.quoteIdentifier(originalTable)));
  }

  public void truncTables(DangerTaskConfirm taskConfirm, String... tableNames) throws java.sql.SQLException {
    Arguments.isTrue(taskConfirm == DangerTaskConfirm.DANGER_TASK_CONFIRMED);

    for (String tableName : tableNames) {
      executeUpdate(STR.fmt("TRUNCATE TABLE {}", this.getDbDialect().quoteIdentifier(tableName)));
    }
  }

  public void resetIdentity(String... tableNames) throws java.sql.SQLException {
    for (String tableName : tableNames) {
      this.getDbDialect().resetIdentity(this, tableName);
    }
  }

  public String getTableNames(boolean tablePkIdentityOnly) throws java.sql.SQLException {
    return JdbcUtils.getTableNames(this, null, null, tablePkIdentityOnly);
  }

  public String getTableNames(String hasColumnName) throws java.sql.SQLException {
    return JdbcUtils.getTableNames(this, null, null, hasColumnName);
  }

  public String getColumnNames(String tableName) throws java.sql.SQLException {
    return JdbcUtils.getColumnNames(this, null, null, tableName);
  }

  public int executeUpdate(String sql) throws java.sql.SQLException {
    try (var stat = this.conn.createStatement()) {
      return stat.executeUpdate(sql);
    }
  }

  public int executeUpdate(String pQuery, Object... params) throws java.sql.SQLException {
    return executeUpdate(pQuery, JdbcUtils.toParameters(params));
  }

  public int executeUpdate(String pQuery, Map<String, Object> params) throws java.sql.SQLException {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      return stat.executeUpdate();
    }
  }

  // Execute utilities

  public String getDistinctValues(String tableName, String columnLabel) throws java.sql.SQLException {
    Arguments.notNull(tableName);
    Arguments.notNull(columnLabel);

    var dbDialect = this.getDbDialect();
    var sql = STR.fmt("SELECT DISTINCT {} FROM {}", dbDialect.quoteIdentifier(columnLabel),
        dbDialect.quoteIdentifier(tableName));

    try (var stat = this.conn.createStatement()) {
      try (var rs = stat.executeQuery(sql)) {
        return JdbcUtils.getDistinctValues(rs, columnLabel);
      }
    }
  }

  public <K, V> Map<K, V> executeMap(String sql, ResultSetMapper<K> keyMapper, ResultSetMapper<V> valueMapper)
      throws java.sql.SQLException {
    return executeMap(sql, keyMapper, valueMapper, new HashMap<>());
  }

  public <K, V> Map<K, V> executeMap(String sql, ResultSetMapper<K> keyMapper, ResultSetMapper<V> valueMapper,
      Map<K, V> map) throws java.sql.SQLException {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        return JdbcUtils.executeMap(rs, keyMapper, valueMapper, map);
      }
    }
  }

  public <K, V> Map<K, V> executeMap(String pQuery, Object[] params, ResultSetMapper<K> keyMapper,
      ResultSetMapper<V> valueMapper) throws java.sql.SQLException {
    return executeMap(pQuery, params, keyMapper, valueMapper, new HashMap<>());
  }

  public <K, V> Map<K, V> executeMap(String pQuery, Object[] params, ResultSetMapper<K> keyMapper,
      ResultSetMapper<V> valueMapper, Map<K, V> map) throws java.sql.SQLException {
    return executeMap(pQuery, JdbcUtils.toParameters(params), keyMapper, valueMapper, map);
  }

  public <K, V> Map<K, V> executeMap(String pQuery, Map<String, Object> params, ResultSetMapper<K> keyMapper,
      ResultSetMapper<V> valueMapper) throws java.sql.SQLException {
    return executeMap(pQuery, params, keyMapper, valueMapper, new HashMap<>());
  }

  public <K, V> Map<K, V> executeMap(String pQuery, Map<String, Object> params, ResultSetMapper<K> keyMapper,
      ResultSetMapper<V> valueMapper, Map<K, V> map) throws java.sql.SQLException {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        return JdbcUtils.executeMap(rs, keyMapper, valueMapper, map);
      }
    }
  }

  public <V> Set<V> executeSet(String sql, ResultSetMapper<V> valueMapper) throws java.sql.SQLException {
    return executeSet(sql, valueMapper, new HashSet<>());
  }

  public <V> Set<V> executeSet(String sql, ResultSetMapper<V> valueMapper, Set<V> set) throws java.sql.SQLException {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        return JdbcUtils.executeSet(rs, valueMapper, set);
      }
    }
  }

  public <V> Set<V> executeSet(String pQuery, Object[] params, ResultSetMapper<V> valueMapper)
      throws java.sql.SQLException {
    return executeSet(pQuery, params, valueMapper, new HashSet<>());
  }

  public <V> Set<V> executeSet(String pQuery, Object[] params, ResultSetMapper<V> valueMapper, Set<V> set)
      throws java.sql.SQLException {
    return executeSet(pQuery, JdbcUtils.toParameters(params), valueMapper, set);
  }

  public <V> Set<V> executeSet(String pQuery, Map<String, Object> params, ResultSetMapper<V> valueMapper)
      throws java.sql.SQLException {
    return executeSet(pQuery, params, valueMapper, new HashSet<>());
  }

  public <V> Set<V> executeSet(String pQuery, Map<String, Object> params, ResultSetMapper<V> valueMapper, Set<V> set)
      throws java.sql.SQLException {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        return JdbcUtils.executeSet(rs, valueMapper, set);
      }
    }
  }

  public <T> List<T> executeList(String sql, ResultSetMapper<T> mapper) throws java.sql.SQLException {
    return executeList(sql, mapper, new ArrayList<>());
  }

  public <T> List<T> executeList(String sql, ResultSetMapper<T> mapper, List<T> list) throws java.sql.SQLException {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        return JdbcUtils.executeList(rs, mapper, list);
      }
    }
  }

  public <T> List<T> executeList(String pQuery, Object[] params, ResultSetMapper<T> mapper)
      throws java.sql.SQLException {
    return executeList(pQuery, params, mapper, new ArrayList<>());
  }

  public <T> List<T> executeList(String pQuery, Object[] params, ResultSetMapper<T> mapper, List<T> list)
      throws java.sql.SQLException {
    return executeList(pQuery, JdbcUtils.toParameters(params), mapper, list);
  }

  public <T> List<T> executeList(String pQuery, Map<String, Object> params, ResultSetMapper<T> mapper)
      throws java.sql.SQLException {
    return executeList(pQuery, params, mapper, new ArrayList<>());
  }

  public <T> List<T> executeList(String pQuery, Map<String, Object> params, ResultSetMapper<T> mapper, List<T> list)
      throws java.sql.SQLException {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        return JdbcUtils.executeList(rs, mapper, list);
      }
    }
  }

  public <T> T executeSingle(String sql, ResultSetMapper<T> mapper) throws java.sql.SQLException {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        return JdbcUtils.executeSingle(rs, mapper);
      }
    }
  }

  public <T> T executeSingle(String pQuery, Object[] params, ResultSetMapper<T> mapper) throws java.sql.SQLException {
    return executeSingle(pQuery, JdbcUtils.toParameters(params), mapper);
  }

  public <T> T executeSingle(String pQuery, Map<String, Object> params, ResultSetMapper<T> mapper)
      throws java.sql.SQLException {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        return JdbcUtils.executeSingle(rs, mapper);
      }
    }
  }

  public <T> T executeScalar(String sql, Class<T> type) throws java.sql.SQLException {
    try (var stat = this.conn.createStatement()) {
      try (var rs = stat.executeQuery(sql)) {

        return JdbcUtils.executeScalar(rs, type);
      }
    }
  }

  public <T> T executeScalar(String pQuery, Object[] params, Class<T> type) throws java.sql.SQLException {
    return executeScalar(pQuery, JdbcUtils.toParameters(params), type);
  }

  public <T> T executeScalar(String pQuery, Map<String, Object> params, Class<T> type) throws java.sql.SQLException {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        return JdbcUtils.executeScalar(rs, type);
      }
    }
  }

  public void executeQuery(String sql, ResultSetHandler handler) throws Exception {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        while (rs.next()) {
          handler.handle(rs);
        }
      }
    }
  }

  public void executeQuery(String pQuery, Object[] params, ResultSetHandler handler) throws Exception {
    executeQuery(pQuery, JdbcUtils.toParameters(params), handler);
  }

  public void executeQuery(String pQuery, Map<String, Object> params, ResultSetHandler handler) throws Exception {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        while (rs.next()) {
          handler.handle(rs);
        }
      }
    }
  }

  public void executeStream(String sql, String streamLabel, OutputStream out, ResultSetHandler handler)
      throws Exception {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        JdbcUtils.executeStream(rs, streamLabel, out, handler);
      }
    }
  }

  public void executeStream(String pQuery, Object[] params, String streamLabel, OutputStream out,
      ResultSetHandler handler) throws Exception {
    executeStream(pQuery, JdbcUtils.toParameters(params), streamLabel, out, handler);
  }

  public void executeStream(String pQuery, Map<String, Object> params, String streamLabel, OutputStream out,
      ResultSetHandler handler) throws Exception {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        JdbcUtils.executeStream(rs, streamLabel, out, handler);
      }
    }
  }

  public void executeStream(String sql, String streamLabel, Writer out, ResultSetHandler handler) throws Exception {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        JdbcUtils.executeStream(rs, streamLabel, out, handler);
      }
    }
  }

  public void executeStream(String pQuery, Object[] params, String streamLabel, Writer out, ResultSetHandler handler)
      throws Exception {
    executeStream(pQuery, JdbcUtils.toParameters(params), streamLabel, out, handler);
  }

  public void executeStream(String pQuery, Map<String, Object> params, String streamLabel, Writer out,
      ResultSetHandler handler) throws Exception {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        JdbcUtils.executeStream(rs, streamLabel, out, handler);
      }
    }
  }

  public void executeNStream(String sql, String streamLabel, Writer out, ResultSetHandler handler) throws Exception {
    try (var stat = this.conn.createStatement()) {
      try (var rs = new ResultSetImpl(stat.executeQuery(sql))) {

        JdbcUtils.executeNStream(rs, streamLabel, out, handler);
      }
    }
  }

  public void executeNStream(String pQuery, Object[] params, String streamLabel, Writer out, ResultSetHandler handler)
      throws Exception {
    executeNStream(pQuery, JdbcUtils.toParameters(params), streamLabel, out, handler);
  }

  public void executeNStream(String pQuery, Map<String, Object> params, String streamLabel, Writer out,
      ResultSetHandler handler) throws Exception {
    var query = new SqlQuery(pQuery);
    try (var stat = prepareStatement(query)) {
      if (params != null) {
        JdbcUtils.setParameters(stat, query, params);
      }
      try (var rs = stat.executeQuery()) {
        JdbcUtils.executeNStream(rs, streamLabel, out, handler);
      }
    }
  }

  // java.sql.Connection

  @Override
  public java.sql.CallableStatement prepareCall(String sql) throws java.sql.SQLException {
    return this.conn.prepareCall(sql);
  }

  @Override
  public java.sql.CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency)
      throws java.sql.SQLException {
    return this.conn.prepareCall(sql, resultSetType, resultSetConcurrency);
  }

  @Override
  public java.sql.CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
      int resultSetHoldability) throws java.sql.SQLException {
    return this.conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
  }

  @Override
  public PreparedStatementImpl prepareStatement(String sql) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(sql));
  }

  @Override
  public PreparedStatementImpl prepareStatement(String sql, int autoGeneratedKeys) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(sql, autoGeneratedKeys));
  }

  @Override
  public PreparedStatementImpl prepareStatement(String sql, int[] columnIndexes) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(sql, columnIndexes));
  }

  @Override
  public PreparedStatementImpl prepareStatement(String sql, String[] columnNames) throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(sql, columnNames));
  }

  @Override
  public PreparedStatementImpl prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
      throws java.sql.SQLException {
    return new PreparedStatementImpl(this.conn.prepareStatement(sql, resultSetType, resultSetConcurrency));
  }

  @Override
  public PreparedStatementImpl prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
      int resultSetHoldability) throws java.sql.SQLException {
    return new PreparedStatementImpl(
        this.conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
  }

  @Override
  public java.sql.Array createArrayOf(String typeName, Object[] elements) throws java.sql.SQLException {
    return this.conn.createArrayOf(typeName, elements);
  }

  @Override
  public java.sql.SQLXML createSQLXML() throws java.sql.SQLException {
    return this.conn.createSQLXML();
  }

  @Override
  public java.sql.Clob createClob() throws java.sql.SQLException {
    return this.conn.createClob();
  }

  @Override
  public java.sql.NClob createNClob() throws java.sql.SQLException {
    return this.conn.createNClob();
  }

  @Override
  public java.sql.Blob createBlob() throws java.sql.SQLException {
    return this.conn.createBlob();
  }

  @Override
  public java.sql.Statement createStatement() throws java.sql.SQLException {
    return this.conn.createStatement();
  }

  @Override
  public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency) throws java.sql.SQLException {
    return this.conn.createStatement(resultSetType, resultSetConcurrency);
  }

  @Override
  public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
      throws java.sql.SQLException {
    return this.conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
  }

  @Override
  public java.sql.Struct createStruct(String typeName, Object[] attributes) throws java.sql.SQLException {
    return this.conn.createStruct(typeName, attributes);
  }

  @Override
  public java.sql.Savepoint setSavepoint() throws java.sql.SQLException {
    return this.conn.setSavepoint();
  }

  @Override
  public java.sql.Savepoint setSavepoint(String name) throws java.sql.SQLException {
    return this.conn.setSavepoint(name);
  }

  @Override
  public void setNetworkTimeout(java.util.concurrent.Executor executor, int milliseconds) throws java.sql.SQLException {
    this.conn.setNetworkTimeout(executor, milliseconds);
  }

  @Override
  public void setAutoCommit(boolean autoCommit) throws java.sql.SQLException {
    this.conn.setAutoCommit(autoCommit);
  }

  @Override
  public void setCatalog(String catalog) throws java.sql.SQLException {
    this.conn.setCatalog(catalog);
  }

  @Override
  public void setClientInfo(java.util.Properties properties) throws java.sql.SQLClientInfoException {
    this.conn.setClientInfo(properties);
  }

  @Override
  public void setClientInfo(String name, String value) throws java.sql.SQLClientInfoException {
    this.conn.setClientInfo(name, value);
  }

  @Override
  public void setHoldability(int holdability) throws java.sql.SQLException {
    this.conn.setHoldability(holdability);
  }

  @Override
  public void setReadOnly(boolean readOnly) throws java.sql.SQLException {
    this.conn.setReadOnly(readOnly);
  }

  @Override
  public void setSchema(String schema) throws java.sql.SQLException {
    this.conn.setSchema(schema);
  }

  @Override
  public void setTransactionIsolation(int level) throws java.sql.SQLException {
    this.conn.setTransactionIsolation(level);
  }

  @Override
  public void setTypeMap(java.util.Map<String, Class<?>> map) throws java.sql.SQLException {
    this.conn.setTypeMap(map);
  }

  @Override
  public int getNetworkTimeout() throws java.sql.SQLException {
    return this.conn.getNetworkTimeout();
  }

  @Override
  public boolean getAutoCommit() throws java.sql.SQLException {
    return this.conn.getAutoCommit();
  }

  @Override
  public String getCatalog() throws java.sql.SQLException {
    return this.conn.getCatalog();
  }

  @Override
  public java.util.Properties getClientInfo() throws java.sql.SQLException {
    return this.conn.getClientInfo();
  }

  @Override
  public String getClientInfo(String name) throws java.sql.SQLException {
    return this.conn.getClientInfo(name);
  }

  @Override
  public int getHoldability() throws java.sql.SQLException {
    return this.conn.getHoldability();
  }

  @Override
  public java.sql.DatabaseMetaData getMetaData() throws java.sql.SQLException {
    return this.conn.getMetaData();
  }

  @Override
  public String getSchema() throws java.sql.SQLException {
    return this.conn.getSchema();
  }

  @Override
  public int getTransactionIsolation() throws java.sql.SQLException {
    return this.conn.getTransactionIsolation();
  }

  @Override
  public java.util.Map<String, Class<?>> getTypeMap() throws java.sql.SQLException {
    return this.conn.getTypeMap();
  }

  @Override
  public java.sql.SQLWarning getWarnings() throws java.sql.SQLException {
    return this.conn.getWarnings();
  }

  @Override
  public boolean isClosed() throws java.sql.SQLException {
    return this.conn.isClosed();
  }

  @Override
  public boolean isReadOnly() throws java.sql.SQLException {
    return this.conn.isReadOnly();
  }

  @Override
  public boolean isValid(int timeout) throws java.sql.SQLException {
    return this.conn.isValid(timeout);
  }

  @Override
  public void releaseSavepoint(java.sql.Savepoint savepoint) throws java.sql.SQLException {
    this.conn.releaseSavepoint(savepoint);
  }

  @Override
  public void abort(java.util.concurrent.Executor executor) throws java.sql.SQLException {
    this.conn.abort(executor);
  }

  @Override
  public void clearWarnings() throws java.sql.SQLException {
    this.conn.clearWarnings();
  }

  @Override
  public void commit() throws java.sql.SQLException {
    this.conn.commit();
  }

  @Override
  public String nativeSQL(String sql) throws java.sql.SQLException {
    return this.conn.nativeSQL(sql);
  }

  @Override
  public void rollback() throws java.sql.SQLException {
    this.conn.rollback();
  }

  @Override
  public void rollback(java.sql.Savepoint savepoint) throws java.sql.SQLException {
    this.conn.rollback(savepoint);
  }

  // java.sql.Wrapper

  @Override
  public boolean isWrapperFor(Class<?> iface) throws java.sql.SQLException {
    return this.conn.isWrapperFor(iface);
  }

  @Override
  public <T> T unwrap(Class<T> iface) throws java.sql.SQLException {
    return this.conn.unwrap(iface);
  }

  // AutoCloseable

  private boolean closed;

  @Override
  public void close() throws java.sql.SQLException {
    if (!this.closed) {
      var outer = this.outer;
      this.conn.close();

      this.outer = null;
      CONNECTION_HOLDER.set(outer);

      this.closed = true;
    }
  }

  @Override
  public String toString() {
    return ObjectUtils.toStringWrapper(this, this.conn);
  }

  private static final ThreadLocalStorage<ConnectionImpl> CONNECTION_HOLDER = new ThreadLocalStorage<>();

  public static ConnectionImpl getCurrent() {
    var conn = CONNECTION_HOLDER.get();
    if (conn == null) {
      throw new IllegalStateException("No connection found in the current thread.");
    }
    return conn;
  }

  public static boolean hasCurrent() {
    return CONNECTION_HOLDER.hasValue();
  }

  public String getDataSourceId() throws UncheckedSQLException {
    return (this.dataSourceId == null) ? JdbcUtils.getDataSourceId(this.conn) : this.dataSourceId;
  }

  public DbDialect getDbDialect() throws UncheckedSQLException {
    return DB_DIALECTS.computeIfAbsent(this.getDataSourceId(), dsId -> {

      try {
        return DbDialect.parse(this.conn.getMetaData().getURL());

      } catch (SQLException ex) {
        throw new UncheckedSQLException(ex.getMessage(), ex);
      }
    });
  }

  private static final ConcurrentMap<String, DbDialect> DB_DIALECTS = new ConcurrentHashMap<>();
}
